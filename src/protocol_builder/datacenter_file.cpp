//
//  datacenter_file.cpp
//  protocol_builder
//
//  Created by Alexandre Martin on 16/08/13.
//  Copyright (c) 2013 alexm. All rights reserved.
//

#include "datacenter_file.hpp"
#include "output_helper.hpp"

void datacenter_file::parse()
{
    const std::regex field_pattern { R"(public var (\w+):([A-Za-z.<>]+);)" };

    std::istringstream ss { _content };
    std::string line;
    std::smatch result;
    while (std::getline(ss, line))
    {
        if (!std::regex_search(line, result, field_pattern))
            continue;
        _fields.emplace_back(result[1], result[2]);
    }
}

datacenter_file::field_list get_base_fields(const std::string & name,
    const std::unordered_map<std::string, datacenter_file> & files)
{
    if (name == "Object")
        return { };
    auto & file = files.at(name);
    auto fields = file.fields();
    fields.splice(std::end(fields), get_base_fields(file.inheritance(), files));
    return fields;
}

std::string get_real_type(const std::string & type, bool vector = false)
{
    if (type == "int")
        return "int32_t";
    else if (type == "uint")
        return vector ? "uint32_t" : "int32_t";
    else if (type == "Boolean")
        return "bool";
    else if (type == "String")
        return "std::string";
    else if (type == "Number")
        return "double";
    else
    {
        const std::regex vector_pattern { R"(Vector.<(\w+)>)" };
        const std::regex double_vector_pattern { R"(Vector.<Vector.<(\w+)>>)" };
        std::smatch result;
        if (std::regex_search(type, result, vector_pattern))
            return "std::vector<" + get_real_type(result[1], true) + ">";
        else if (std::regex_search(type, result, double_vector_pattern))
            return "std::vector<std::vector<" + get_real_type(result[1], true) + ">";
        return to_cpp_case(type);
    }
}

std::string datacenter_file::cpp_output(const std::unordered_map<std::string, datacenter_file>
                                        & files) const
{
    auto name = to_cpp_case(_class_name);
    auto base_name = to_cpp_case(_inheritance);
    auto casify = [](const std::pair<std::string, std::string> & pair)
    {
        return std::make_pair(to_cpp_case(pair.first), get_real_type(pair.second));
    };
    auto fields = _fields;
    std::transform(std::begin(fields), std::end(fields), std::begin(fields), casify);

    auto base_fields = get_base_fields(_inheritance, files);
    std::transform(std::begin(base_fields), std::end(base_fields),
                   std::begin(base_fields), casify);

    auto all_fields = base_fields;
    all_fields.insert(std::end(all_fields), std::begin(fields), std::end(fields));

    output o;
    o << "//  Generated by desperion protocol_builder";
    o.next().next() << "#ifndef d2fstream_" << name << "_hpp";
    o.next() << "#define d2fstream_" << name << "_hpp";
    o.next().next() << "namespace datacenter";
    o.next() << "{";
    o.indent().next() << "struct " << name << " : ";
    if (_inheritance != "Object")
        o << base_name;
    else
        o << "data_holder";
    o.next() << "{";
    o.indent();
    for (auto && f : fields)
        o.next() << f.second << " " << f.first << ";";

    /* construction */
    if (!all_fields.empty())
        o.next().next() << name << "() = default;";

    o.next().next() << name << "(";
    bool first = true;
    for (auto && f : all_fields)
    {
        if (!first)
            o << ", ";
        first = false;
        o << "const " << f.second << " & " << f.first;
    }
    o << ")";
    if (!all_fields.empty())
        o << " : ";
    first = true;
    if (!base_fields.empty())
    {
        o << base_name << " { ";
        for (auto && f : base_fields)
        {
            if (!first)
                o << ", ";
            first = false;
            o << f.first;
        }
        o << " }";
    }
    for (auto && f : fields)
    {
        if (!first)
            o << ", ";
        first = false;
        o << f.first << " { " << f.first << " }";
    }
    o.next() << "{";
    o.next() << "}";

    /* deserialization */
    o.next().next() << name << "(data_object && data)";
    if (_inheritance != "Object")
        o << " : " << base_name << " { std::forward<data_object>(data) }";
    o.next() << "{";
    o.indent();
    for (auto && f : fields)
    {
        auto dofus_name =
            std::find_if(std::begin(_fields), std::end(_fields),
                         [&f](const std::pair<std::string, std::string> & pair)
                         {
                             return to_cpp_case(pair.first) == f.first;
                         })->first;
        o.next() << "acquire(" << f.first << ", data.second.at(\"" << dofus_name << "\"));";
    }
    o.unindent().next() << "}";

    o.next().next() << "data_object to_d2o(const d2o_writer &);";
    o.unindent().next() << "};";

    /* serialization */
    o.unindent().next().next() << "#ifdef d2fstream_d2o_writer_hpp";
    o.indent().next() << "data_object to_d2o(const d2o_writer & file)";
    o.next() << "{";
    o.indent().next() << "data_object data";
    if (_inheritance != "Object")
        o << " = " << base_name << "::to_d2o(file)";
    o << ";";
    o.next() << "data.first = file.get_class_id_for_type<" << name << ">();";
    for (auto && f : fields)
    {
        auto dofus_name =
        std::find_if(std::begin(_fields), std::end(_fields),
                     [&f](const std::pair<std::string, std::string> & pair)
                     {
                         return to_cpp_case(pair.first) == f.first;
                     })->first;
        o.next() << "release(" << f.first << ", data.second[\"" << dofus_name << "\"], file);";

    }
    o.next() << "return data;";
    o.unindent().next() << "}";
    o.unindent().next() << "#endif";
    o.next() << "}";
    o.next() << "#endif";

    return o.str();
}