//  Generated by desperion protocol_builder

#ifndef d2fstream_effect_hpp
#define d2fstream_effect_hpp

namespace datacenter
{
    struct effect : data_holder
    {
        int32_t id;
        int32_t description_id;
        int32_t icon_id;
        int32_t characteristic;
        int32_t category;
        std::string operator;
        bool show_in_tooltip;
        bool use_dice;
        bool force_min_max;
        bool boost;
        bool active;
        bool show_in_set;
        int32_t bonus_type;
        bool use_in_fight;
        int32_t effect_priority;
        
        effect() = default;
        
        effect(const int32_t & id, const int32_t & description_id, const int32_t & icon_id, const int32_t & characteristic, const int32_t & category, const std::string & operator, const bool & show_in_tooltip, const bool & use_dice, const bool & force_min_max, const bool & boost, const bool & active, const bool & show_in_set, const int32_t & bonus_type, const bool & use_in_fight, const int32_t & effect_priority) : id { id }, description_id { description_id }, icon_id { icon_id }, characteristic { characteristic }, category { category }, operator { operator }, show_in_tooltip { show_in_tooltip }, use_dice { use_dice }, force_min_max { force_min_max }, boost { boost }, active { active }, show_in_set { show_in_set }, bonus_type { bonus_type }, use_in_fight { use_in_fight }, effect_priority { effect_priority }
        {
        }
        
        effect(data_object && data)
        {
            acquire(id, data.second.at("id"));
            acquire(description_id, data.second.at("descriptionId"));
            acquire(icon_id, data.second.at("iconId"));
            acquire(characteristic, data.second.at("characteristic"));
            acquire(category, data.second.at("category"));
            acquire(operator, data.second.at("operator"));
            acquire(show_in_tooltip, data.second.at("showInTooltip"));
            acquire(use_dice, data.second.at("useDice"));
            acquire(force_min_max, data.second.at("forceMinMax"));
            acquire(boost, data.second.at("boost"));
            acquire(active, data.second.at("active"));
            acquire(show_in_set, data.second.at("showInSet"));
            acquire(bonus_type, data.second.at("bonusType"));
            acquire(use_in_fight, data.second.at("useInFight"));
            acquire(effect_priority, data.second.at("effectPriority"));
        }
        
        data_object to_d2o(const d2o_writer &);
    };

#ifdef d2fstream_d2o_writer_hpp
    data_object to_d2o(const d2o_writer & file)
    {
        data_object data;
        data.first = file.get_class_id_for_type<effect>();
        release(id, data.second["id"], file);
        release(description_id, data.second["descriptionId"], file);
        release(icon_id, data.second["iconId"], file);
        release(characteristic, data.second["characteristic"], file);
        release(category, data.second["category"], file);
        release(operator, data.second["operator"], file);
        release(show_in_tooltip, data.second["showInTooltip"], file);
        release(use_dice, data.second["useDice"], file);
        release(force_min_max, data.second["forceMinMax"], file);
        release(boost, data.second["boost"], file);
        release(active, data.second["active"], file);
        release(show_in_set, data.second["showInSet"], file);
        release(bonus_type, data.second["bonusType"], file);
        release(use_in_fight, data.second["useInFight"], file);
        release(effect_priority, data.second["effectPriority"], file);
        return data;
    }
#endif
}
#endif