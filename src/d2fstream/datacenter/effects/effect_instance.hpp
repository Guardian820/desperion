//  Generated by desperion protocol_builder

#ifndef d2fstream_effect_instance_hpp
#define d2fstream_effect_instance_hpp

namespace datacenter
{
    struct effect_instance : data_holder
    {
        int32_t effect_id;
        int32_t target_id;
        std::string target_mask;
        int32_t duration;
        int32_t delay;
        int32_t random;
        int32_t group;
        int32_t modificator;
        bool trigger;
        bool hidden;
        int32_t zone_size;
        int32_t zone_shape;
        int32_t zone_min_size;
        
        effect_instance() = default;
        
        effect_instance(const int32_t & effect_id, const int32_t & target_id, const std::string & target_mask, const int32_t & duration, const int32_t & delay, const int32_t & random, const int32_t & group, const int32_t & modificator, const bool & trigger, const bool & hidden, const int32_t & zone_size, const int32_t & zone_shape, const int32_t & zone_min_size) : effect_id { effect_id }, target_id { target_id }, target_mask { target_mask }, duration { duration }, delay { delay }, random { random }, group { group }, modificator { modificator }, trigger { trigger }, hidden { hidden }, zone_size { zone_size }, zone_shape { zone_shape }, zone_min_size { zone_min_size }
        {
        }
        
        effect_instance(data_object && data)
        {
            acquire(effect_id, data.second.at("effectId"));
            acquire(target_id, data.second.at("targetId"));
            acquire(target_mask, data.second.at("targetMask"));
            acquire(duration, data.second.at("duration"));
            acquire(delay, data.second.at("delay"));
            acquire(random, data.second.at("random"));
            acquire(group, data.second.at("group"));
            acquire(modificator, data.second.at("modificator"));
            acquire(trigger, data.second.at("trigger"));
            acquire(hidden, data.second.at("hidden"));
            acquire(zone_size, data.second.at("zoneSize"));
            acquire(zone_shape, data.second.at("zoneShape"));
            acquire(zone_min_size, data.second.at("zoneMinSize"));
        }
        
        data_object to_d2o(const d2o_writer &);
    };

#ifdef d2fstream_d2o_writer_hpp
    data_object to_d2o(const d2o_writer & file)
    {
        data_object data;
        data.first = file.get_class_id_for_type<effect_instance>();
        release(effect_id, data.second["effectId"], file);
        release(target_id, data.second["targetId"], file);
        release(target_mask, data.second["targetMask"], file);
        release(duration, data.second["duration"], file);
        release(delay, data.second["delay"], file);
        release(random, data.second["random"], file);
        release(group, data.second["group"], file);
        release(modificator, data.second["modificator"], file);
        release(trigger, data.second["trigger"], file);
        release(hidden, data.second["hidden"], file);
        release(zone_size, data.second["zoneSize"], file);
        release(zone_shape, data.second["zoneShape"], file);
        release(zone_min_size, data.second["zoneMinSize"], file);
        return data;
    }
#endif
}
#endif