//  Generated by desperion protocol_builder

#ifndef d2fstream_weapon_hpp
#define d2fstream_weapon_hpp

namespace datacenter
{
    struct weapon : item
    {
        int32_t ap_cost;
        int32_t min_range;
        int32_t range;
        int32_t max_cast_per_turn;
        bool cast_in_line;
        bool cast_in_diagonal;
        bool cast_test_los;
        int32_t critical_hit_probability;
        int32_t critical_hit_bonus;
        int32_t critical_failure_probability;
        
        weapon() = default;
        
        weapon(const int32_t & id, const int32_t & name_id, const int32_t & type_id, const int32_t & description_id, const int32_t & icon_id, const int32_t & level, const int32_t & real_weight, const bool & cursed, const int32_t & use_animation_id, const bool & usable, const bool & targetable, const double & price, const bool & two_handed, const bool & etheral, const int32_t & item_set_id, const std::string & criteria, const std::string & criteria_target, const bool & hide_effects, const bool & enhanceable, const bool & non_usable_on_another, const int32_t & appearance_id, const bool & secret_recipe, const std::vector<uint32_t> & drop_monster_ids, const int32_t & recipe_slots, const std::vector<uint32_t> & recipe_ids, const bool & bonus_is_secret, const std::vector<effect_instance> & possible_effects, const std::vector<uint32_t> & favorite_sub_areas, const int32_t & favorite_sub_areas_bonus, const int32_t & ap_cost, const int32_t & min_range, const int32_t & range, const int32_t & max_cast_per_turn, const bool & cast_in_line, const bool & cast_in_diagonal, const bool & cast_test_los, const int32_t & critical_hit_probability, const int32_t & critical_hit_bonus, const int32_t & critical_failure_probability) : item { id, name_id, type_id, description_id, icon_id, level, real_weight, cursed, use_animation_id, usable, targetable, price, two_handed, etheral, item_set_id, criteria, criteria_target, hide_effects, enhanceable, non_usable_on_another, appearance_id, secret_recipe, drop_monster_ids, recipe_slots, recipe_ids, bonus_is_secret, possible_effects, favorite_sub_areas, favorite_sub_areas_bonus }, ap_cost { ap_cost }, min_range { min_range }, range { range }, max_cast_per_turn { max_cast_per_turn }, cast_in_line { cast_in_line }, cast_in_diagonal { cast_in_diagonal }, cast_test_los { cast_test_los }, critical_hit_probability { critical_hit_probability }, critical_hit_bonus { critical_hit_bonus }, critical_failure_probability { critical_failure_probability }
        {
        }
        
        weapon(data_object && data) : item { std::forward<data_object>(data) }
        {
            acquire(ap_cost, data.second.at("apCost"));
            acquire(min_range, data.second.at("minRange"));
            acquire(range, data.second.at("range"));
            acquire(max_cast_per_turn, data.second.at("maxCastPerTurn"));
            acquire(cast_in_line, data.second.at("castInLine"));
            acquire(cast_in_diagonal, data.second.at("castInDiagonal"));
            acquire(cast_test_los, data.second.at("castTestLos"));
            acquire(critical_hit_probability, data.second.at("criticalHitProbability"));
            acquire(critical_hit_bonus, data.second.at("criticalHitBonus"));
            acquire(critical_failure_probability, data.second.at("criticalFailureProbability"));
        }
        
        data_object to_d2o(const d2o_writer &);
    };

#ifdef d2fstream_d2o_writer_hpp
    data_object to_d2o(const d2o_writer & file)
    {
        data_object data = item::to_d2o(file);
        data.first = file.get_class_id_for_type<weapon>();
        release(ap_cost, data.second["apCost"], file);
        release(min_range, data.second["minRange"], file);
        release(range, data.second["range"], file);
        release(max_cast_per_turn, data.second["maxCastPerTurn"], file);
        release(cast_in_line, data.second["castInLine"], file);
        release(cast_in_diagonal, data.second["castInDiagonal"], file);
        release(cast_test_los, data.second["castTestLos"], file);
        release(critical_hit_probability, data.second["criticalHitProbability"], file);
        release(critical_hit_bonus, data.second["criticalHitBonus"], file);
        release(critical_failure_probability, data.second["criticalFailureProbability"], file);
        return data;
    }
#endif
}
#endif